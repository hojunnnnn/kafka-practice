# kafka-practice


kafka를 사용하며 마주칠 수 있는 데이터 정합성 문제, 메시지 유실, 중복 처리 등의 다양한 이슈를 해결하고 데이터 일관성과 메시지의 신뢰성을 보장하는 구조를 직접 구현해보기 위한 프로젝트입니다.

<br/>

## 프로젝트 목표

> 1. Transactional Outbox Pattern을 통해 비즈니스 로직과 Kafka 메시지 발행을 원자적으로 처리하고, Eventual Consistency를 보장한다.
>
> 2. 중복 메시지 처리를 방지하기 위해 Idempotent한 Consumer를 구현하여 Exactly-Once에 가까운 효과를 얻는다.

<br/>

## Producer

### 해결하고자 하는 문제
**1.** **비즈니스 로직과 메시지 발행 간 정합성 문제**
- **문제:** 
비즈니스 로직과 메시지 발행이 별도의 시스템에서 일어나므로, 둘 중 하나만 성공하고 다른 하나는 실패할 수 있다.
- **해결:** 
event_outbox 테이블을 사용해 메시지를 트랜잭션의 일부로 저장함으로써 두 작업을 원자적으로 만든다.

**2.** **시스템 장애시 메시지 유실**
- **문제:** 
브로커로 메시지를 보내다가 실패할 경우(네트워크 이슈 등) 해당 메시지는 유실된다.
- **해결:** 
메시지를 저장하고, 이후에 발행함으로써 장애 상황에도 메시지를 복구할 수 있다.

<br/>

### Transactional Outbox Pattern을 통해 얻은 이점
- 일관성 : 비즈니스 로직과 이벤트 발행이 하나의 트랜잭션으로 이루어지므로 항상 일치한다.
- 안정성 : 이벤트를 Outbox 테이블에 저장하므로 시스템 장애 상황에도 메시지 손실을 방지한다.
- 성능 : 메시지 발행은 비동기적으로 이루어져 메인 트랜잭션의 성능에 영향을 주지 않는다.

<br/>


## Consumer

### 해결하고자 하는 문제
**1.** **컨슈머 처리 중 장애시 데이터 정합성 문제**
- **문제:** 
컨슈머가 메시지를 처리하던 중 장애가 발생하면, 일부 작업만 수행된 채 중단될 수 있다.
이 때 Kafka로 Ack가 전달되지 않아 메시지는 재전송되고, 데이터 정합성 문제가 발생할 수 있다.
- **해결:** 
메시지 처리 로직과 Inbox 테이블에 ID를 기록하는 작업을 하나의 트랜잭션으로 묶어 원자성을 보장하면,
일부 작업만 반영되거나 누락되지 않아 재시도 시에도 안전하게 처음부터 재처리되며, 데이터 불일치나 중복 처리 없이 정합성을 유지할 수 있다.

**2.** **컨슈머 처리 후 Ack 전 시스템 장애시 중복 처리 문제**
- **문제:** 
컨슈머 작업 완료 후 DB 커밋은 했지만 Ack를 보내기 전 장애가 발생하면 Kafka는 해당 메시지를 처리되지 않은 것으로 인식하고,
동일 메시지를 다시 전송하여 중복 처리가 발생할 수 있다.
- **해결:** 
Inbox 테이블을 사용해 이미 처리된 메시지인지 판별하여 중복 처리를 방지한다.

<br/>

### Inbox Table을 통해 얻은 이점
- 멱등성 : 이미 처리된 메시지인지 확인하여 중복 처리를 방지하고 Excatly-Once에 가까운 효과를 얻는다.
- 원자성 : 메시지 처리 작업과 Inbox 테이블에 기록하는 작업을 하나의 트랜잭션으로 묶어 원자성을 보장한다.
- 신뢰성 : 장애나 중복 상황에도 동일 작업이 중복 처리되지 않도록 보장하여 시스템 상태의 신뢰성을 보장한다.

<br/>

## 최종 다이어그램
<img width="1906" height="700" alt="최종 다이어그램2" src="https://github.com/user-attachments/assets/6851d96f-713b-4894-942f-03818b916ecb" />

